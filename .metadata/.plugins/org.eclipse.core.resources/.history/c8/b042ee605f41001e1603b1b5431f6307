 package com.kh.dot.member.controller;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.servlet.http.HttpSession;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.SessionAttribute;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.kh.dot.member.model.vo.Member;
import com.kh.dot.security.model.service.SecurityService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Controller
public class MemberController {
	
	private SecurityService mService;
	private BCryptPasswordEncoder bcrypotPasswordEncoder;
	
	
	
	@GetMapping("/memberLogin.me")
	public String memberLogin() {
		return "/member/memberLogin";
	}
	
	@PostMapping("/login.me")
	public String loginMember(
							@ModelAttribute Member m , 
							HttpSession session , 
							Model model,
							@SessionAttribute(required = false) String nextUrl
			) {
		log.info("찍어보자구 {} , {}",m , m);
		//암호화 후 로그인 요청 처리
		UserDetails loginUser = mService.loadUserByUsername(m.getUserId());
		// loginUser의 userPwd는 암호화된 상태의 비밀번호
		// m안의 userPwd는 암호화전 상태의 비밀번호
		
		// BcrpytPasswordEncoder객체의 matches 메소드 사용
		// matches(평문, 암호문)을 작성하면 내부적으로 두 값이 일치하는 검사 후 일치하면 true/ 일치하지 않으면 false
		
		String url = "";
		if(loginUser != null && bcrypotPasswordEncoder.matches(m.getUserPwd(), loginUser.getPassword())) {
			//로그인 성공
			if(loginUser.getPassword().equals("Y")) {
				session.setAttribute("alertMsg","비밀번호를 변경해주세요");
			}
			model.addAttribute("loginUser",loginUser);
			url = "redirect:"+(nextUrl != null ? nextUrl : "/");
			
			// 사용한 nextUrl제거
			model.addAttribute("nextUrl",null);
		}else {
			model.addAttribute("errorMsg","아이디 또는 비밀번호가 일치하지 않습니다.");
			url = "common/errorPage";
		}
		
		return url;
	}
	
	@GetMapping("/myPage.me")
	public String myPage(Model model , 
			// 2) HandlerMapping에 보안인증된 사용자 Authentication 요청하기
			Authentication authentication) {
		
		// 1) SecurityContextHolder로부터 사용자의 인증정보 가져오기
		//Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		Member principal = (Member) authentication.getPrincipal();
		model.addAttribute("loginUser",principal);
		log.info("authentication = {}", authentication);
		return "member/myPage";
	}
	
	@PostMapping("/update.me")
	public String updateMember(
			Member updateMember,
			Authentication oldAuthentication,
			RedirectAttributes ra
			) {
		log.info("updateMember = {}",updateMember); // password, authorities X
		// 1. 업무록직 : DB의 Member테이블에 회원정보 수정요청을 보낸 회원 정보 수정 => 생략
		
		// 2. 변경된 회원정보를 DB에서 얻어온 후 Session에 저장하는 대신, SecurityContext의 Authentication객체를 직접 수정
		
		// 누락된 비밀번호 추가
		updateMember.setUserPwd(((Member)oldAuthentication.getPrincipal()).getPassword());
		Collection<? extends GrantedAuthority> oldAuthorities = oldAuthentication.getAuthorities(); // "ROLE_USER","ROLE_ADMIN",....
		List<SimpleGrantedAuthority> authorities = new ArrayList();
		for( GrantedAuthority auth :  oldAuthorities) {
			SimpleGrantedAuthority simpleAuth = new SimpleGrantedAuthority(auth.getAuthority()); // 문자열형태의 권한을 매개변수로 auth객체 생성
			authorities.add(simpleAuth);
		}
		updateMember.setAuthorities(authorities);
		
		// 새로운 Authentication객체 생성
		Authentication newAuthentication = new UsernamePasswordAuthenticationToken(
													updateMember, oldAuthentication.getCredentials(),oldAuthentication.getAuthorities()
												);
		
		// SecurityContextHolder에 새로운 인증객체 등록
		SecurityContextHolder.getContext().setAuthentication(newAuthentication);
		
		// 사용자 페이지 리다이렉트
		return "redirect:/myPage.me";
	}
}
